<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ArcZ - Telegram Bot Controller</title>

<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" rel="stylesheet">

<style>
/* ================= ARCZ THEME ================= */
:root {
  --blue-dark: #020617;
  --blue-mid: #0f172a;
  --blue-soft: #1e3a8a;
  --blue-light: #38bdf8;
  --blue-neon: #0ea5e9;
  --text-main: #e5e7eb;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  background: linear-gradient(135deg, var(--blue-dark), var(--blue-mid));
  color: var(--text-main);
  font-family: system-ui;
  min-height: 100vh;
  padding-top: 70px;
}

/* ================= TOPBAR ================= */
.topbar {
  position: fixed;
  top: 0; left: 0; right: 0;
  height: 60px;
  background: linear-gradient(135deg, var(--blue-dark), var(--blue-mid));
  border-bottom: 1px solid var(--blue-soft);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 100;
  box-shadow: 0 5px 20px rgba(0,0,0,.6);
}

.topbar span {
  color: var(--blue-light);
  font-weight: 600;
  letter-spacing: 1px;
  text-shadow: 0 0 10px rgba(56,189,248,.6);
}

/* ================= CARD ================= */
.card {
  width: 100%;
  max-width: 480px;
  margin: 30px auto;
  background: linear-gradient(160deg, #020617, #020617ee);
  padding: 22px;
  border-radius: 18px;
  border: 1px solid var(--blue-soft);
  box-shadow: 0 10px 30px rgba(0,0,0,.7);
  position: relative;
}

.card::before {
  content: '';
  position: absolute;
  top: 0; left: 0;
  width: 100%;
  height: 2px;
  background: linear-gradient(
    90deg,
    transparent,
    var(--blue-light),
    transparent
  );
}

.card-title {
  text-align: center;
  margin-bottom: 20px;
  color: var(--blue-light);
  text-shadow: 0 0 10px rgba(56,189,248,.6);
}

/* ================= INPUT ================= */
.input-group {
  margin-bottom: 18px;
}

.input-group label {
  font-size: 13px;
  margin-bottom: 6px;
  display: block;
  color: #93c5fd;
}

.input-group input,
.input-group textarea {
  width: 100%;
  padding: 14px;
  border-radius: 12px;
  border: 1px solid var(--blue-soft);
  background: var(--blue-dark);
  color: #fff;
  font-size: 14px;
}

.input-group input:focus,
.input-group textarea:focus {
  outline: none;
  border-color: var(--blue-light);
  box-shadow: 0 0 12px rgba(56,189,248,.4);
}

/* ================= BUTTON ================= */
.btn {
  width: 100%;
  padding: 14px;
  border-radius: 14px;
  font-size: 14px;
  background: transparent;
  border: 2px solid var(--blue-light);
  color: var(--blue-light);
  cursor: pointer;
  transition: .4s;
  margin-top: 10px;
}

.btn:hover {
  background: var(--blue-light);
  color: #020617;
  box-shadow:
    0 0 15px var(--blue-light),
    0 0 40px var(--blue-light);
  transform: scale(1.05);
}

.btn.primary {
  border-color: var(--blue-neon);
  color: var(--blue-neon);
}

.btn.primary:hover {
  background: var(--blue-neon);
  box-shadow:
    0 0 20px var(--blue-neon),
    0 0 50px var(--blue-neon);
}

/* ================= STATUS ================= */
.status-bar {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
}

.status {
  flex: 1;
  background: rgba(15,23,42,.8);
  border: 1px solid var(--blue-soft);
  border-radius: 12px;
  padding: 12px;
  text-align: center;
  box-shadow: inset 0 0 10px rgba(56,189,248,.15);
}

.online { color: #22c55e }
.offline { color: #ef4444 }

/* ================= LOG ================= */
.log {
  height: 220px;
  overflow-y: auto;
  background: rgba(15,23,42,.8);
  border: 1px solid var(--blue-soft);
  border-radius: 12px;
  padding: 12px;
  font-size: 13px;
  box-shadow: inset 0 0 10px rgba(56,189,248,.15);
}

.log div {
  margin-bottom: 6px;
}

/* ================= RANGE ================= */
input[type=range] {
  width: 100%;
}
</style>
</head>

<body>

<header class="topbar">
  <span><i class="fas fa-robot"></i> ArcZ Telegram Bot Controller</span>
</header>

<div class="card">
  <h3 class="card-title"><i class="fas fa-plug"></i> Bot Configuration</h3>

  <div class="input-group">
    <label>Bot Token</label>
    <input id="botToken" placeholder="Telegram Bot Token">
  </div>

  <div class="input-group">
    <label>Target Chat ID</label>
    <input id="targetId" placeholder="Chat ID">
  </div>

  <button class="btn primary" onclick="testConnection()">Test Connection</button>
  <button class="btn" onclick="saveConfig()">Save Config</button>
</div>

<div class="card">
  <h3 class="card-title"><i class="fas fa-signal"></i> Status</h3>
  <div class="status-bar">
    <div class="status">Messages<br><b id="messageCount">0</b></div>
    <div class="status">Bot<br><b id="botStatus" class="offline">Offline</b></div>
  </div>
</div>

<div class="card">
  <h3 class="card-title"><i class="fas fa-bomb"></i> Spammer</h3>

  <div class="input-group">
    <label>Message</label>
    <textarea id="spamText" rows="3">Hallo</textarea>
  </div>

  <div class="input-group">
    <label>Count</label>
    <input type="number" id="count" value="10">
  </div>

  <div class="input-group">
    <label>Delay (ms)</label>
    <input type="number" id="delay" value="0">
  </div>

  <button class="btn primary" onclick="startSpam()" id="startBtn">
    <i class="fas fa-play"></i> Start
  </button>
  <button class="btn" onclick="stopSpam()" id="stopBtn" style="display:none">
    <i class="fas fa-stop"></i> Stop
  </button>
</div>

<div class="card">
  <h3 class="card-title"><i class="fas fa-history"></i> Log</h3>
  <div class="log" id="log"></div>
</div>

<script>
        // STATE MANAGEMENT
        const state = {
            botToken: '',
            targetId: '',
            isConnected: false,
            isSpamming: false,
            messageCount: 0,
            customMessage: 'Hallo'
        };

        // DOM ELEMENTS
        const el = {
            // Status
            messageCount: document.getElementById('messageCount'),
            botStatus: document.getElementById('botStatus'),
            
            // Setup
            botToken: document.getElementById('botToken'),
            targetId: document.getElementById('targetId'),
            
            // Spam
            spamText: document.getElementById('spamText'),
            messagePreview: document.getElementById('messagePreview'),
            count: document.getElementById('count'),
            countRange: document.getElementById('countRange'),
            delay: document.getElementById('delay'),
            delayRange: document.getElementById('delayRange'),
            startBtn: document.getElementById('startBtn'),
            stopBtn: document.getElementById('stopBtn'),
            log: document.getElementById('log'),
            
            // Toast
            toast: document.getElementById('toast')
        };

        // UTILITY FUNCTIONS
        function showToast(message, type = 'info') {
            el.toast.textContent = message;
            el.toast.style.color = type === 'error' ? 'var(--accent-red)' : 
                                 type === 'success' ? 'var(--accent-green)' : 
                                 type === 'warning' ? '#eab308' : 'var(--accent-pink)';
            
            el.toast.classList.add('show');
            setTimeout(() => el.toast.classList.remove('show'), 3000);
        }

        function logMessage(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            el.log.appendChild(entry);
            el.log.scrollTop = el.log.scrollHeight;
        }

        // UPDATE MESSAGE PREVIEW
        function updateMessagePreview() {
            const text = el.spamText.value.trim();
            if (text) {
                el.messagePreview.textContent = text;
                state.customMessage = text;
            } else {
                el.messagePreview.textContent = 'No message entered';
                state.customMessage = '';
            }
        }

        // TAB SWITCHING
        function switchTab(tabName) {
            // Update nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.querySelectorAll('.nav-tab').forEach(tab => {
                if (tab.onclick.toString().includes(tabName)) {
                    tab.classList.add('active');
                }
            });

            // Update content sections
            document.querySelectorAll('.content-section').forEach(section => {
                section.classList.remove('active');
            });
            
            document.getElementById(tabName).classList.add('active');
        }

        // SYNC RANGE AND NUMBER INPUTS
        function syncInputs(rangeId, numberId) {
            const range = document.getElementById(rangeId);
            const number = document.getElementById(numberId);
            
            range.addEventListener('input', () => {
                number.value = range.value;
            });
            
            number.addEventListener('input', () => {
                const value = Math.min(Math.max(parseInt(number.min), parseInt(number.value)), parseInt(number.max));
                number.value = value;
                range.value = value;
            });
        }

        // TELEGRAM API FUNCTIONS
        async function testConnection() {
            const token = el.botToken.value.trim();
            const target = el.targetId.value.trim();
            
            if (!token) {
                showToast('Enter bot token first!', 'error');
                logMessage('‚ùå Enter bot token first', 'error');
                return;
            }
            
            state.botToken = token;
            state.targetId = target;
            
            logMessage('üîó Testing connection to Telegram API...', 'info');
            
            // Save to localStorage
            localStorage.setItem('tg_bot_token', token);
            if (target) localStorage.setItem('tg_chat_id', target);
            
            try {
                const response = await fetch(`https://api.telegram.org/bot${token}/getMe`);
                const data = await response.json();
                
                if (data.ok) {
                    state.isConnected = true;
                    
                    // Update bot status
                    el.botStatus.textContent = 'Online';
                    el.botStatus.className = 'status-value online';
                    
                    logMessage('‚úÖ Bot connected successfully!', 'success');
                    logMessage(`ü§ñ Bot Name: ${data.result.first_name}`, 'success');
                    logMessage(`üë§ Username: @${data.result.username}`, 'success');
                    logMessage(`üÜî Bot ID: ${data.result.id}`, 'success');
                    
                    showToast(`‚úÖ Connected: @${data.result.username}`, 'success');
                } else {
                    throw new Error('Connection failed');
                }
            } catch (error) {
                state.isConnected = false;
                el.botStatus.textContent = 'Offline';
                el.botStatus.className = 'status-value offline';
                logMessage('‚ùå Connection failed', 'error');
                showToast('‚ùå Connection failed', 'error');
            }
        }

        function saveConfig() {
            localStorage.setItem('tg_bot_token', el.botToken.value);
            localStorage.setItem('tg_chat_id', el.targetId.value);
            logMessage('‚úÖ Configuration saved', 'success');
            showToast('‚úÖ Configuration saved', 'success');
        }

        function loadConfig() {
            const token = localStorage.getItem('tg_bot_token');
            const target = localStorage.getItem('tg_chat_id');
            
            if (token) el.botToken.value = token;
            if (target) el.targetId.value = target;
        }

        // SPAM FUNCTIONS
        async function startSpam() {
            if (!state.isConnected) {
                showToast('‚ùå Connect bot first!', 'error');
                logMessage('‚ùå Connect bot first', 'error');
                return;
            }
            
            // Get custom message
            state.customMessage = el.spamText.value.trim();
            
            if (!state.customMessage) {
                showToast('‚ùå Enter message text first!', 'error');
                logMessage('‚ùå Enter message text first', 'error');
                return;
            }
            
            const count = parseInt(el.count.value) || 10;
            const delayMs = parseInt(el.delay.value) || 0;
            
            if (count < 1 || count > 100) {
                showToast('‚ùå Count must be 1-100', 'error');
                return;
            }
            
            state.isSpamming = true;
            el.startBtn.style.display = 'none';
            el.stopBtn.style.display = 'flex';
            
            logMessage(`üöÄ Starting spam attack...`, 'info');
            logMessage(`üìä Target: ${state.targetId}`, 'info');
            logMessage(`üìù Message: "${state.customMessage.substring(0, 50)}${state.customMessage.length > 50 ? '...' : ''}"`, 'info');
            logMessage(`üî¢ Count: ${count} messages`, 'info');
            logMessage(`‚è±Ô∏è Delay: ${delayMs}ms`, 'info');
            
            let success = 0;
            let failed = 0;
            
            for (let i = 0; i < count && state.isSpamming; i++) {
                try {
                    const response = await fetch(`https://api.telegram.org/bot${state.botToken}/sendMessage`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            chat_id: state.targetId,
                            text: state.customMessage
                        })
                    });
                    
                    if (response.ok) {
                        success++;
                        state.messageCount++;
                        
                        el.messageCount.textContent = state.messageCount;
                        
                        // Show progress every 5 messages or first message
                        if ((i + 1) % 5 === 0 || i === 0) {
                            logMessage(`‚úÖ Sent ${i + 1}/${count} messages`, 'success');
                        }
                    } else {
                        failed++;
                        logMessage(`‚ùå Failed message #${i+1}`, 'error');
                    }
                } catch (error) {
                    failed++;
                    logMessage(`‚ùå Error sending message #${i+1}`, 'error');
                }
                
                if (delayMs > 0) {
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                }
            }
            
            stopSpam();
            
            const successRate = Math.round((success / count) * 100);
            logMessage(`‚úÖ Attack completed!`, 'success');
            logMessage(`üìä Results: ${success}/${count} successful (${successRate}%)`, 'success');
            showToast(`‚úÖ Sent: ${success}/${count} messages`, 'success');
        }

        function stopSpam() {
            state.isSpamming = false;
            el.startBtn.style.display = 'flex';
            el.stopBtn.style.display = 'none';
            
            logMessage('‚èπÔ∏è Spam stopped by user', 'warning');
        }

        // INITIALIZATION
        document.addEventListener('DOMContentLoaded', function() {
            // Sync range inputs
            syncInputs('countRange', 'count');
            syncInputs('delayRange', 'delay');
            
            // Load saved config
            loadConfig();
            
            // Update message preview when text changes
            el.spamText.addEventListener('input', updateMessagePreview);
            
            // Add welcome message to log
            setTimeout(() => {
                logMessage('üöÄ Telegram Bot Controller ready', 'success');
                logMessage('‚öôÔ∏è Configure bot token and target ID first', 'info');
                logMessage('üí¨ Enter your custom message in the Spam tab', 'info');
                
                // Update initial preview
                updateMessagePreview();
                
                // Auto-test if token exists
                if (el.botToken.value) {
                    logMessage('üîç Auto-testing saved configuration...', 'info');
                    setTimeout(() => testConnection(), 1000);
                }
            }, 500);
        });
</script>

</body>
</html>